#!/usr/bin/env python3

import argparse
import subprocess
import datetime
import shutil
import os
import sys

startup_timestamp = datetime.datetime.now()
default_filename = f"mustang-output-{startup_timestamp.year}{startup_timestamp.month}{startup_timestamp.day}-{startup_timestamp.hour}-{startup_timestamp.minute}-{startup_timestamp.second}"
default_logname = f"mustang-run-{startup_timestamp.year}{startup_timestamp.month}{startup_timestamp.day}-{startup_timestamp.hour}-{startup_timestamp.minute}-{startup_timestamp.second}.log"

parser = argparse.ArgumentParser(prog='mustang', description='Parse command-line arguments as a wrapper for the mustang_engine binary.')
parser.add_argument("-p", "--paths", required=True, nargs='+', metavar='PATH', 
        help='One or more POSIX-like paths to recursively traverse within a MarFS instance and catalog objects along.')
parser.add_argument("-t", "--threads-max", required=False, type=int, default=128, metavar = "THREADS",
        help='Maximum number of threads that will be allowed to traverse directories at one time.')
parser.add_argument("-o", "--output", required=False, type=str, default=default_filename, metavar="FILE", 
        help='Output file where names of catalogged objects (as maintained in the program\'s hashtable) will be written.')
parser.add_argument("-hc", "--hc", "--hashtable-capacity", required=False, type=int, default=16, choices=range(1, 64), metavar="PWR", 
        help='Power of 2 determining output capacity (e.g., default 16 -> 2^16 -> capacity = 65536).')
parser.add_argument("-cc", "--cc", "--cache-capacity", "--id-cache-capacity", required=False, type=int, default=16, metavar="CAPACITY", 
        help='Maximum number of unique MarFS object IDs that will be \"cached\" at one time in per-thread data structures (default: 16).') 

# TODO: add argument for task queue capacity with Linux SIZE_MAX (queried with sys.maxsize) being the default

logging_group = parser.add_mutually_exclusive_group()
logging_group.add_argument("-l", "--logfile", "--log-file", required=False, type=str, nargs=1, default=default_logname, metavar="LOGFILE",
        help='Log file where thread-specific state changes, warnings, and errors will be recorded. Exclusive with --use-stderr.')
logging_group.add_argument("--use-stderr", required=False, action='store_true', 
        help='Do not log in a separate file and print all messages to stderr. Exclusive with -l/--logfile/--log-file.')

if __name__ == '__main__':
    args = parser.parse_args()

    if not(os.access("./mustang_engine", os.F_OK)):
        print("Executable for MUSTANG engine does not exist! Please build it and try again.")
        exit(1)

    engine_args = ["mustang_engine"]
    engine_args.append(str(args.threads_max))
    engine_args.append(str(args.hc))
    engine_args.append(str(args.cc))

    init_output_handle = f"{args.output}_in-progress"

    final_handle = f"{args.output}_finalized"

    engine_args.append(init_output_handle)

    if (args.use_stderr):
        engine_args.append("stderr")
    else:
        engine_args.append(args.logfile)

    for path_arg in args.paths:
        tmp_arg = ''

        # If path contains a trailing glob (e.g., "/campaign/*"), attempt to 
        # slice the string so that the trailing glob is excluded
        if (path_arg[-1] == '*'):
            print("WARNING: ignoring trailing glob (\"*\") in path.")
            tmp_arg = path_arg[:-1:1]
            print(f"Attempting to use prefix path \"{tmp_arg}\".")
        
        # Otherwise, if a glob is found _not_ at the trailing index of a string 
        # (end index of .find() is exclusive, so string actually searched until 
        # index -2), reject the path outright
        if (path_arg.find('*', 0, -1) != -1):
            print("ERROR: non-trailing glob (\"*\") found in string. Skipping this path argument.")
            continue

        # If string was sliced to exclude a trailing glob, append that new 
        # string; else, simply append the argument as normal
        if (tmp_arg):
            engine_args.append(tmp_arg)
        else:
            engine_args.append(path_arg)

    print(f"Using invocation: {engine_args}")

    # TODO: use Popen() constructor and manually poll returncode
    try:
        subprocess.run(engine_args)
        shutil.move(init_output_handle, final_handle) 
    except subprocess.CalledProcessError:
        print("WARNING: mustang_engine process returned a non-zero exit code. Check logs for more details.")
    except:
        print("Some other error occurred. Please try again.")
    finally:
        with open(final_handle, 'r') as hashtable:
            line_count = len(hashtable.readlines())
            if line_count >= (2**(args.hc)):
                print("WARNING: The output hashtable had all entries filled, meaning object IDs may have been lost if the number of unique objects encountered exceeded the hashtable's actual capacity.")
                print(f"If you are concerned about object IDs being lost, you should perform another run with a greater capacity (this run had capacity argument \"{args.hc}\" resulting in {2**(args.hc)} maximum entries).")

